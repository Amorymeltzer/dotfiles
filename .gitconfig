[hub]
protocol = https

[github]
user = Amorymeltzer

[user]
name = Amory Meltzer
email = tryharder

[credential]
helper = osxkeychain

[core]
# Use custom `.gitignore`
excludesfile = ~/.global-gitignore
# editor and pager set in include

# Treat spaces before tabs, lines that are indented with 8 or more spaces,
# and all kinds of trailing whitespace as an error
# [default] trailing-space: look for spaces at the end of a line
# [default] space-before-tab: look for spaces before tabs at beginning of line
whitespace = space-before-tab,indent-with-non-tab,trailing-space

# Make `git rebase` safer on OS X 10.7+ with autosave/versions
# More info: <http://www.git-tower.com/blog/make-git-rebase-safe-on-osx/>
trustctime = false

# Prevent showing files whose names contain non-ASCII symbols as unversioned.
# http://michael-kuehnel.de/git/2014/11/21/git-mac-osx-and-german-umlaute.html
precomposeunicode = false

# Use 12 characters for the abbreviated commit hash. See:
# http://blog.cuviper.com/2013/11/10/how-short-can-git-abbreviate/
# Via: http://git.io/QXnAqw
# abbrev = 12

[commit]
verbose = true
gpgSign = true
# gpg.program set in include

[alias]
# Fix mindless `git git log` stuff
git = !exec git

h = help
hc = help config
cfg = config
cfgg = config --get
# List all aliases
aliases = "!git config -l | grep alias | cut -c 7-"
# All options
configs = config -l


notifications = "!browser https://github.com/notifications"
allpulls = "!browser https://github.com/pulls"
allissues = "!browser https://github.com/issues"

init-commit = "!git init && git commit --allow-empty -m 'Initial commit'"

c = commit
cm = commit -m
amend = commit --amend
commend = commit --amend --no-edit
# These two not quite sensible, but roughly mirror the aca/acc behavior below
ca = commit --amend
cc = commit --amend --no-edit
amend-resetauthor = commit --amend --reset-author
commend-resetauthor = commit --amend --no-edit --reset-author
amr = commit --amend --reset-author
cor = commit --amend --no-edit --reset-author

a = add
aa = add -A
all = add -A
# Don't do anything unless there are any staged changes
# More specific (staged) than diff-index
aas = "!git add -A; git diff --staged --name-only --quiet || git status --short --branch"
acm = "!git add -A; git diff --staged --name-only --quiet || git commit -m"
aca = "!git add -A; git diff --staged --name-only --quiet || git commit --amend"
acc = "!git add -A; git diff --staged --name-only --quiet || git commit --amend --no-edit"
ap  = add -p
ai  = add -p

co = checkout
com = checkout master
cog = checkout gh-pages
cod = checkout dev
gom = checkout master
gog = checkout gh-pages
god = checkout dev
wc = whatchanged

stat = status
s = status --short --branch
sn = status --untracked=no

# stash
st = stash
# Completion treats these as "stash" so won't complete with the list, which sucks
stp = stash pop
pop = stash pop
sta = stash apply
stu = stash push
stup = stash push -p		# Or just stash -p
stum = stash push -m
stump = stash push -pm
std = stash drop
drop = stash drop
stl = stash list
sts = stash show
stb = stash branch

# Various log shorthands and improvements, some accessed via .bashrc aliases
l = log --oneline
l5 = log --oneline -5

full = log --pretty=fuller
lf1 = log --pretty=fuller -1

# All commits, and all important/labeled commits
la = log --graph --decorate --oneline --all
las = log --graph --decorate --oneline --all --simplify-by-decoration

ld = log --pretty=format:"%C(yellow)%h\\ %ad%C(auto)%d\\ %Creset%s%Cblue\\ [%an]" --decorate --date=short
ld5 = log --pretty=format:"%C(yellow)%h\\ %ad%C(auto)%d\\ %Creset%s%Cblue\\ [%an]" --decorate --date=short -5

# Potentially overridden in local-config to use date=human after 2.21, see also recent-branches-by-commit and [log]
lr = log --pretty=format:"%C(yellow)%h\\ %ad%C(auto)%d\\ %Creset%s%Cblue\\ [%an]" --decorate --date=relative
lr5 = log --pretty=format:"%C(yellow)%h\\ %ad%C(auto)%d\\ %Creset%s%3Cblue\\ [%an]" --decorate --date=relative -5
lg = log --color --graph --pretty=format:'%C(yellow)%h%Creset%C(auto)%d%Creset %s %Cgreen(A: %cr, C: %ar)%C(blue) [%an]%Creset' --abbrev-commit --date=relative

graph = lg

lm = log --oneline --decorate master..HEAD
llm = log --decorate master..HEAD

lum = log --oneline --decorate @{upstream}..HEAD
llum = log --decorate @{upstream}..HEAD
# Probably not that useful, but technically possible...
lmu = log --oneline --decorate HEAD..@{upstream}
llmu = log --decorate HEAD..@{upstream}

# Relies on split-from alias, log of commits since splitting this branch
ls = "!git log $(git split-from)..head"

# Show new commits, most useful if done right after a pull or fetch
# --name-status to show files and status change (could do --stat too)
# https://git.wiki.kernel.org/index.php/Aliases
# Should probably use $@ in more places to allow subsequent flags to pass

# @ == HEAD, but head is complicated
# Can prefix with a ref (master, dev, etc.), otherwise assumes current branch
# @{1} is the previous value of the ref (eg. prior to an amend), which is
# *almost* the same as ORIG_HEAD, which is the previous value of head before a
# drastic/risky operation (man gitrevisions and https://stackoverflow.com/a/967611/2521092)
# @{0} is thus @ aka HEAD
new = !git log --name-status $1@{1}..$1@{0} "$@"


# Should prefer this so that autocomplete distinguishes between cherry-pick and cherry
cp = cherry-pick
cpa = cherry-pick --abort
cpc = cherry-pick --continue
cps = cherry-pick --skip
cpq = cherry-pick --quit

# Like "git show myfile", but uses the last commit that changed "myfile".
showlast = log -n 1 -p
last = log -n 1 -p

# --name-only in log just... adds the name, not *only* shows it?  Weird.
# Use format=format: to force the entries to be newlines, removed by grep (`-v '^$'` better?)
most-changed-files = "!git log --name-only --format=format: | grep . | sort | uniq -c | sort -r | head"
# List contributors by number of commits
contributors = "!git --no-pager shortlog --summary --numbered --no-merges"
top-contributors = "!t() { c=${1:-10}; git --no-pager shortlog --summary --numbered --no-merges | head -n $c; }; t"
contributors-merges = "!git --no-pager shortlog --summary --numbered"
top-contributors-merges = "!t() { c=${1:-10}; git --no-pager shortlog --summary --numbered | head -n $c; }; t"
# Provide sha or --author=Name/Email
# -i ignores case
whois = "!git log -i -1 --pretty='format:%an <%ae>'"

difflog = log -u
rl = reflog --decorate

cl = clone

# Show verbose output
tags = tag -n
remotes = remote -v

br = branch
# git-extras also has delete-branch, which does upstream
brd = branch -D
# Vaguely risky, but -D outputs the sha, so can easily restore
# Will fail if not a branch (e.g. we had checked out a commit, resulting in a detached head)
delete-last-branch = branch -D @{-1}
# Would prefer this as -simple and -long as just branches, but aliases can't
# overwrite scripts, and unixorn added a bunch of pluralizing scripts in #117
branches = branch -a
local-branches = "!git branch -a --color | grep -v remotes"
branches-long = branch -a -vv
local-branches-long = "!git branch -avv --color | grep -v remotes"
branch-name = copy-branch-name

# More detailed script in unixorn, with dates
recently-checkedout-branches = "!git reflog -n 100 | egrep -io \"moving from ([^[:space:]]+)\" | awk '{ print $3 }' | awk ' !x[$0]++' | egrep -v '^[a-f0-9]{40}$' | head -n 10"
# https://stackoverflow.com/a/5188364/2521092
# Only show most recent 15, could also use branch --sort=-committerdate as of 2.7
# Potentially overridden in local-config to use date=human after 2.21, see also lor and [log]
recent-branches-by-commit = for-each-ref --sort=-committerdate --count=15 refs/heads/ --format='%(color:red)%(objectname:short)%(color:reset) %(color:yellow)%(refname:short)%(color:reset) (%(color:green)%(committerdate:relative)%(color:reset)) %(contents:subject) %(color:blue)[%(authorname)]%(color:reset)'

# Create and/or go to a branch
# With git 2.23, uses switch -c; can do the same with checkout -b
go = "!f() { git switch -c \"$1\" 2> /dev/null || git switch \"$1\"; }; f"

# Easily rememberable
remove-merged-branches = delete-merged-branches
list-large-files = big-object-report

# Find the commit this commit split off from
# Feels like --fork-point should help but no???
# The trailing # means the $1 and $2 arguments don't get gobbled up along the
# way, should probably make better use of this throughout this config
split-from = "!git merge-base ${1:-master} ${2:-HEAD} #"


rb = rebase
reb = rebase
reba = rebase --abort
rebc = rebase --continue
rebs = rebase --skip
rebq = rebase --quit
rbm = rebase master
rebm = rebase master
rebd = rebase dev
rebu = rebase @{upstream}
# Interactive rebase with the selected number of latest commits
# Allow for additional flags after
rebi = "!git rebase -i HEAD~$1 \"${@:2}\" #"
# As above, but with the --exec option
rebix = "!git rebase -i -x \"$2\" HEAD~$1 \"${@:3}\" #"
rebim = rebase -i master
# Relies on split-from alias, rebases commits since splitting this branch
rebis = "!git rebase -i $(git split-from)"


# Aww yeah.  Autoplace fixes where needed in interactive rebase with --autosquash or rebase.autoSquash
fixup = commit --fixup
# git-extras has a squash command
squash-fixup = commit --squash
# Do the above but automatically move into a rebase
# Need to verify then save sha since since refs like head~2 are treated
# differently by commit and rebase -i (specifically around merges)
fixup-pick = "!sha=$(git rev-parse $1) && git commit --fixup $sha && git rebase -i $sha^ #"
squash-fixup-pick = "!sha=$(git rev-parse $1) && git commit --squash $sha && git rebase -i $sha^ #"

# Push and Pull
po = push origin
pou = push -u origin
pom = push origin master
pog = push origin gh-pages
pod = push origin dev
# Use rebase to prevent unnecessary commits
pum = pull --rebase origin master
puo = pull --rebase origin
pu = pull --rebase
# Personal remote
pa = push Amorymeltzer
pau = push -u Amorymeltzer
pam = push Amorymeltzer master
please = push --force-with-lease

d = diff
dw = diff --word-diff
dc = diff --cached
dwc = diff --cached --word-diff
patience = diff --patience
dn = diff --name-only
dm = diff master
dmc = diff --cached master
du  = diff @{upstream}
dun = diff --name-only @{upstream}
duc = diff --cached @{upstream}
# Compare commit to the state before it
dp = "!f() { c=${1:-HEAD}; git diff $c~ $c; }; f"
# Relies on split-from alias, diffs since splitting this branch
ds = "!git diff $(git split-from)"
dsc = "!git diff --cached $(git split-from)"

# Easier difftool, but default to gui (at least until smerge/emerge makes sense...)
# git diff-tool --tool-help for options
dt = difftool -g
mt = mergetool -g

# Goodness (summary of diff lines added/removed/total)
# FIXME TODO: Colorize
gn = goodness
gnc = goodness --cached

# Copy sha hashes.  Trim new lines since sh's echo doesn't accept -n
hash = "!r() { h=${1:-HEAD}; rev=$(git rev-parse $h); echo $rev; echo $rev | tr -d '\n' | pbcopy; }; r"
sha = "!r() { h=${1:-HEAD}; rev=$(git rev-parse --short $h); echo $rev; echo $rev | tr -d '\n' | pbcopy; }; r"
short = sha
# Find collisions from a given prefix
collisions = "!r() { git rev-list --all | grep ^$1 | while read commit; do git --no-pager log -n1 --pretty=format:'%H %ci %an %s%n' $commit; done; }; r"

unstage = reset HEAD --
re = reset
reh = reset --hard
res = reset --soft
rehu = reset --hard @{upstream}
resu = reset --soft @{upstream}

# m just too simple/easy for merge
mg = merge
mgd = merge dev
mga = merge --abort
mgc = merge --continue
mgq = merge --quit

# Merge changes when GitHub suggestions have been merged
merge-suggestions = merge --ff-only @{push}

# Assume/Unassume changes
assume = update-index --assume-unchanged
unassume = update-index --no-assume-unchanged
assumed = "!git ls-files -v | grep ^h | cut -c 3-"
assumeall = "!git st -s | awk {'print $2'} | xargs git assume"
unassumeall = "!git assumed | xargs git update-index --no-assume-unchanged"

ignored = "!git clean -ndX | sed 's/Would remove //g'"

# Show list of files in a conflict state, also present in git-extra-commands
# faster than diff --name-only --diff-filter=U
conflicts = "!git ls-files -u | awk '{print $4}' | sort -u"
# List of leftover conflict markers
# See https://stackoverflow.com/a/49382772/2521092
conflict-markers = diff --check
# Open merge conflicts in editor
edit-unmerged = "!git conflicts | xargs $VISUAL"
add-unmerged = "!git conflicts | xargs git add"

# Script to clustergit check all repos
scan = "!~/bin/gscan"

# Should really learn to use gitk: faster than kraken or vs, and like 85% of all the other apps
# gui for blame or browser (or citool)
k = !gitk

# Find branches containing commit
fb = "!f() { git branch -a --contains $1; }; f"
# Find tags containing commit
ft = "!f() { git describe --always --contains $1; }; f"
# Find commits by source code
fc = "!f() { git log --pretty=format:'%C(yellow)%h  %Cblue%ad  %Creset%s%Cgreen  [%an] %Cred%d' --decorate --date=short -S$1; }; f"
# Find commits by commit message
fm = "!f() { git log --pretty=format:'%C(yellow)%h  %Cblue%ad  %Creset%s%Cgreen  [%an] %Cred%d' --decorate --date=short --grep=$1; }; f"

# Show number of commits by minimum length
# Josh Stone @cuviper https://blog.cuviper.com/2013/11/10/how-short-can-git-abbreviate/
uniq-abbrev=!git rev-list --all --abbrev=0 --abbrev-commit | awk '{ a[length] += 1 } END { for (len in a) print len, a[len] }'

# https://gist.github.com/phinze/83387035c233db7c521e by @phinze
# git timespan FROMREF [TOREF] [FORMAT]
# TOREF: defaults to HEAD
# FORMAT: defaults to %mm%dd
# uses `ddiff` from the `dateutils` package
# available via: brew install dateutils, apt-get install dateutils, etc
timespan = "!f() { one=$(git log -n 1 --format=%ai $1); two=$(git log -n 1 --format=%ai ${2:-HEAD}); ddiff -f ${3:-%mm-%dd-%Hh-%Mm} \"$one\" \"$two\"; }; f"

dad = "!curl https://icanhazdadjoke.com/"

[push]
default = simple
# Make `git push` push relevant annotated tags when pushing branches out.
followTags = true
# Currently unsupported by GitHub https://github.community/t/push-signed/938/4
# gpgSign = true

[pull]
ff = only
# Probably obviates the need for the pum/puo/pu aliases?
rebase = true

[fetch]
prune = true

[merge]
# Include summaries of merged commits in newly created merge commit messages
log = true
# Display base with ||| between ours and theirs, seems useful if a bit weird
conflictStyle = diff3
guitool = opendiff

[mergetool]
prompt = false

[rebase]
# Automatically stash before rebase; allows for dirty rebases
autoStash = true
# Automatically file squash! or fixup! prefixed commits where appropriate, --no-autosquash to turn off for incompatible options
autoSquash = true
# warn but proceed if commits dropped via exclusion, use drop instead
missingCommitsCheck = warn

[apply]
whitespace = warn

[log]
# --date=human added in 2.21, used in local-config, see also lr and recent-branches-by-commit
date = local
abbrevCommit = true
# Follow file rename/move, only if one file
follow = true

[stash]
# stash show shows diff along with stat (showStat, defaults to true) like stash show -p
showPatch = true

[status]
showStash = true

[interactive]
# Mainly for add -p, but don't require pressing enter to proceed
singleKey = true

[help]
# If there's only suggestion from a typo, automatically call it after 1.5s
autocorrect = 15

[diff]
compactionHeuristic = true
noprefix = true
guitool = opendiff

[difftool]
prompt = false

# Special diffs for special cases
[diff "bin"]
textconv = hexdump -v -C

[diff "zip"]
textconv = unzip -v

[diff "png"]
binary = true
textconv = hexdump -v -C

[diff "jpg"]
binary = true
textconv = hexdump -v -C

[diff "jpeg"]
binary = true
textconv = hexdump -v -C

[diff "plist"]
textconv = plutil -p

[color]
# Use colors in Git commands that are capable of colored output when output is
# to the terminal, not pipes or files (use --color when appropriate)
ui = true

[color "branch"]
current = cyan
local = normal
remote = green

[color "diff"]
meta = white
frag = magenta
old = red
new = green
commit = yellow
whitespace = red reverse

[color "status"]
# header = normal
branch = cyan
added = magenta
changed = green
untracked = cyan
unmerged = red

# Mainly for diff-so-fancy
[color "diff-highlight"]
oldNormal = red# bold
oldHighlight = red bold 52
newNormal = green# bold
newHighlight = green bold 22

[color "blame"]
highlightRecent = yellow, 36 months ago, blue, 1 months ago, white

[color "interactive"]
# prompt = blue #bold
header = magenta bold		# Not sure what this applies to...
help = yellow
error = red bold # Takes the help color unless otherwise specificed, default is red bold

[gc]
auto = 256

[tag]
# Implies annotated, which is good behavior anyway
gpgSign = true
# gpg.program set in include

[blame]
coloring = highlightRecent
# human in local-config
date = local

[rerere]
# Tries to remember resolutions of merge conflicts for the next time, seems useful in theory?
enabled = true

[filter "media"]
required = true
clean = git media clean %f
smudge = git media smudge %f

[filter "lfs"]
process = git-lfs filter-process
required = true
clean = git-lfs clean -- %f
smudge = git-lfs smudge -- %f

# Customize based on local environment, etc.
# eg: core.editor, core.pager, gpg, icdiff, ghi
# Example file at ~/.local-gitconfig.example
[include]
path = ~/.local-gitconfig
path = ~/.config/git/priv-gitconfig