#!/usr/bin/env bash
# diary by Amory Meltzer
# Basic script to handle a basic diary

function help {
    cat <<END_HELP
Usage: $(basename "$0") [-h] [new|notes|last|show|rand|log|remove|rm|delete|YYY-MM-DD|stats]

  Without any parameters, diary will open today's entry for you; if it hasn't
  been started yet, it will create the file with, and populate it with the
  content of a "notes" file.  If you're not in the directory defined by the
  "\$DIARY_DIR" environment variable, it will exit.

  Other options:

  new			Create a new file, without opening
  notes			Edit the notes file
  last			Display the last diary entry
  show [YYYY-MM-DD]	Show a given entry, or the last entry if no date provided
  rand			Display a random diary entry
  log			Commit today's file, only if the directory is managed by git
  remove, rm, delete	Remove today's entry, if present
  YYYY-MM-DD		Display the diary entry from a specific day
  stats			Display some basic statistics
END_HELP
}

while getopts 'h' opt; do
    case $opt in
	h) help "$0"
	   exit 0;;
	*) exit 0;;
    esac
done

if [[ -z "$DIARY_DIR" ]]; then
    echo "No diary directory configured, please set \$DIARY_DIR"
    exit 1
elif [[ $(pwd) != "$DIARY_DIR" ]]; then
    echo "Not in $DIARY_DIR, exiting"
    exit 1
fi


today=$(date +"%Y-%m-%d").md

function newDay {
    if [[ ! -f $today ]]; then
	title=$(date +"%A, %B %d, %Y")

	# Try to check ssid, insert a reminder to note location if not at home
	if [[ -n $(command -v ssid) ]] && [[ -n $HOME_SSID ]] && [[ $HOME_SSID != "$(ssid)" ]]; then
	    away=" (INSERTLOCATION)"
	fi

	printf "# %s%s\n\n" "${title}" "${away}" > "$today"
	notes=$(cat notes)
	if [[ -n $notes ]]; then
	    printf "## Thoughts\n\n" >> "$today"
	    printf "%s\n\n" "$notes" >> "$today"
	fi
	printf "## Morning\n\n\n## Afternoon\n\n\n## Evening\n" >> "$today"
    fi
}

if [[ ! $1 ]]; then
    newDay
    $VISUAL "$today"
else
    # Optional .md to allow for bash completion, removed in showDate
    function validDate {
	[[ $1 =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}(\.md)?$ ]]
    }
    function showDate {
	if date="${1/.md}" && validDate "$date" && [[ -f "$date.md" ]]; then
	    cat "$date.md"
	else
	    echo "No entry for $date"
	    exit 1
	fi
    }

    # Show a specific date
    if validDate "$1"; then
	showDate "$1"
    else
	function showLast {
	    cat "$(find . -maxdepth 1 -name '*.md' | tail -n 2 | grep -v "$today" | tail -n 1)"
	}

	case "$1" in
	    "new") newDay;;
	    "notes") $VISUAL notes;;
	    "last")
		# Display latest entry, not including today's
		showLast;;
	    "show")
		# Show the specific entry, second param by this point
		if [[ $2 ]]; then
		    showDate "$2"
		else
		    showLast
		fi;;
	    "rand")
		# Display a random entry
		# OSX doesn't have shuf, approximate it via perl
		# https://stackoverflow.com/a/6511327/2521092
		if [[ ! $(command -v 2>/dev/null shuf) ]]; then
		    function shuf() {
			perl -MList::Util=shuffle -e 'print shuffle(<>);';
		    }
		fi
		cat "$(find . -maxdepth 1 -name '*.md' | shuf | head -n 1)";;
	    "remove"|"rm"|"delete")
		[ -f "$today" ] && rm "$today" || echo "No entry for today found";;
	    "log")
		# Commit entry, if git
		[[ ! $(git rev-parse --is-inside-work-tree 2>/dev/null) ]] && exit 1
		# Reset the index, just in case
		git reset HEAD --

		# Ensure there's just one file, and that it's today
		status=$(git status --porcelain)
		if [[ -z $status ]]; then
		    echo "No files present, exiting"
		    exit 1
		elif [[ $(wc -l <<< "$status") -ne 1 ]]; then
		    echo "Too many files present, exiting"
		    exit 1
		elif [[ "$(cut -c 4- <<< "$status")" != "$today" ]]; then
		    echo "File isn't for today, exiting"
		    exit 1
		fi

		git add "$today"
		# Commit if untracked, amend if already present
		if [[ "$(cut -c 1-2 <<< "$status")" == "??" ]]; then
		    git commit -m "$today"
		elif [[ "$(cut -c 1-2 <<< "$status")" == " M" ]]; then
		    git commit --amend --no-edit
		else
		    echo "$status"
		    echo "Unknown situation, exiting"
		    exit 1
		fi;;
	    "stats")
		# Basic stats, should expand this (days done (since date?), etc.)
		# This should probably be find but whatever
		files=$(grep -E "^\d{4}-\d{2}-\d{2}\.md$" < <(ls -1))
		total=$(wc -l <<<"$files" | tr -d ' ')
		# Here so the command command isn't called multiple times
		hasSpark=$(command -v spark)

		if [[ $total -gt 0 ]]; then
		    results=()
		    while IFS='' read -r line; do results+=("$line"); done < <(cut -f 1 -d - <<<"$files" | sort | uniq -c)
		    # Used below, 1-indexing
		    mons=(null Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec)
		    for result in "${results[@]}"; do
			# Bash expansion matching is awful
			# Remove two leading spaces
			result="${result#'  '}"

			# Split on single space; first is entry count, second is year
			year="${result#*' '}"
			count="${result%' '*}"
			echo "$year:"

			# Display monthly stats first
			yfiles=$(grep "$year" <<<"$files")
			# Hold onto counts
			spark=()
			# Note the leading ! in the array, means iterate over the index
			for i in "${!mons[@]}"; do
			    # 1-indexing
			    if [ "$i" -eq 0 ]; then
				continue
			    fi
			    # Zero-pad month number
			    find=$(printf "%02d" "$i")
			    mcount=$(echo "$yfiles" | grep -cE "^\d{4}-$find-\d{2}\.md$" | tr -d ' ')
			    if [ "$mcount" -gt 0 ]; then
				mon=${mons[$i]}
				echo -e "\t$mon: $mcount"
				# Add to spark array
				spark+=("$mcount")
			    fi
			done

			# Display annual total
			echo -n "$count "
			if [[ $count -ge 2 ]]; then
			    echo -n "entries"

			    if [[ -n "${hasSpark}" ]] && [ ${#spark[@]} -gt 1 ]; then
				echo -n " "
				spark "${spark[@]}"
			    else
				echo
			    fi
			else
			    echo -n "entry"
			fi
		    done
		    echo
		    echo "$total total"
		else
		    echo "No entries found"
		fi;;
	    *) echo "Unknown option"
	       exit 1;;
	esac
    fi
fi
